# AUTOGENERATED! DO NOT EDIT! File to edit: 08_batch_mode.ipynb (unless otherwise specified).

__all__ = ['batch_results', 'plot_batch', 'plot_avg_and_dots', 'plot_avg_and_errorbars', 'plot_boxplot']

# Internal Cell
import os
import pandas as pd
from .core import *
from .mri import *
import altair as alt
from tqdm.notebook import tqdm
from tempfile import mkdtemp
from functools import partial

# Internal Cell
def dicom_to_Image(file):
    '''Reading the Dicom file and bringing the image into correct format and orientation for downstream evaluations'''
    dcm = pydicom.dcmread(file)
    img = Tensor(dcm.pixel_array.astype(np.int16))
    img = windowed(img, dcm.WindowWidth, dcm.WindowCenter)
    img = Image(torch.stack([img, img, img]))    # to convert Tensor into Image object, 3 dimensions are needed
    img = img.flip_lr()
    img = img.rotate(90)
    return img

# Cell
def batch_results(images, model, eval_functions, true_masks=None, components=['bg','LV','MY','RV']):
    ''' Evaluation of the models performance across multiple images and transformations

    -images (list): paths for dicom files with which the model should be evaluated
    -model: model to be evaluated
    -eval_functions (list): names of the eval functions from misas.core that should be evaluated
    -true_masks (list, optional): paths of png files with true masks for dicoms in 'images' in the same order as 'images'
    -components (list, optional): classes that will be evaluated by the eval functions

    Returns: list of Pandas dataFrames, that contains one dataFrame for each image with the columns: 'parameter', 'bg', 'LV', 'MY', 'RV', 'File'
    '''
    results = []
    for x in tqdm(eval_functions, leave=False):
        trfm_result = []
        for index, i in enumerate(images):
            img = lambda: dicom_to_Image(i)
            tmp = tempfile.mkdtemp()
            if true_masks == None:
                truth_path = os.path.join(tmp, "current_truth.png")
                truth = model.predict(img())[0]
                truth.save(truth_path)
                true_mask = lambda: open_mask(truth_path)
            elif true_masks != None:
                true_mask = lambda: open_mask(true_masks[index])
            df = x(img(), true_mask(), model, components=components)
            df["File"] = i
            trfm_result.append(df)
            shutil.rmtree(tmp)
        trfm_result = pd.concat(trfm_result)
        results.append(trfm_result)
    return results

# Cell
def plot_batch(df_results, plot_function=plot_avg_and_dots):
    '''
    Creates and displays the plots with the data as returned by the batch_results functions.

    Positional arguments:
    -df_results (list): dataframes which contains one dataFrame for each transformation in a format as it is returned by `batch_results`
    Keyword arguments:
    -plot_function:
        - plot_avg_and_errorbars: plots the average of the dice score of all images across the parameters and shows the standarddeviation as errorbars
        - plot_avg_and_dots: plots the average of the dice score and additionally shows the single datapoints instead of errorbars
        - plot_boxplot

    Returns: List with altair.FacetChart objects
    '''
    plots = []
    for i in df_results:
        plot = plot_function(i)
        plots.append(plot)
    for p in plots:
        p.display()
    return plots

# Cell
def plot_avg_and_dots(df, draw_line=True):
    '''
    Plots the average dice score and shows the single data points

    Positional arguments:
    -df (pd.DataFrame object): columns: 'parameter', 'bg', 'LV', 'MY', 'RV', 'File'

    Returns: altair.FacetChart object
    '''
    melt_results = df.melt(id_vars=df.columns[0], value_vars=df.columns[2:5])
    dot_plot = alt.Chart(melt_results
                ).mark_point(
                ).encode(x=melt_results.columns[0], y="value", color=alt.Color("variable")
                ).properties(width=400, height=200
                ).interactive()
    if draw_line == True:
        avg_line_plot = alt.Chart(melt_results
                    ).mark_line(
                    ).encode(x=melt_results.columns[0], y="average(value)", color=alt.Color("variable")
                    ).properties(width=400, height=200
                    ).interactive()
        plot = alt.layer(dot_plot, avg_line_plot).facet(column="variable")
    else:
        plot = dot_plot.facet(column="variable")
    return plot

# Cell
def plot_avg_and_errorbars(df):
    '''
    Plots the average dice score and shows the stdev as errorbars.

    Positional arguments:
    -df (pd.DataFrame object): columns: 'parameter', 'bg', 'LV', 'MY', 'RV', 'File'

    Returns: altair.FacetChart object
    '''
    melt_results = df.melt(id_vars=df.columns[0], value_vars=df.columns[2:5])
    avg_line_plot = alt.Chart(melt_results
                ).mark_line(
                ).encode(x=melt_results.columns[0], y="average(value)", color=alt.Color("variable")
                ).properties(width=400, height=200
                ).interactive()
    error_bars = alt.Chart(melt_results
                ).mark_errorbar(extent='stdev'
                ).encode(x=melt_results.columns[0], y="value", color=alt.Color("variable"))
    plot = alt.layer(avg_line_plot, error_bars).facet(column="variable")
    return plot

# Cell
def plot_boxplot(df):
    '''
    Plots the average dice score as boxplots

    Positional arguments:
    -df (pd.DataFrame object): columns: 'parameter', 'bg', 'LV', 'MY', 'RV', 'File'

    Returns: altair.FacetChart object
    '''
    melt_results = df.melt(id_vars=df.columns[0], value_vars=df.columns[2:5])
    plot = alt.Chart(melt_results
                ).mark_boxplot(extent="min-max", size=5
                ).encode(x=alt.X(melt_results.columns[0]), y=alt.Y("value"), color=alt.Color("variable")
                ).properties(width=400, height=200
                ).facet(column="variable"
                ).interactive()
    return plot